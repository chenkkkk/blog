> 原子性，也就是要么全部做完，要么全部不做

> 在多进程（线程）访问资源时，能够确保所有其他的进程（线程）都不在同一时间内访问相同的资源。原子操作（atomic operation）是不需要同步，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。

硬件机制所保证的原子性
>* （1）一些基本的内存读写操作是本身已经被硬件提供了原子性保证（例如读写单个字节的操作）；
>* （2）一些需要保证原子性但是没有被第（1）条机制提供支持的操作（例如read-modify-write）可以通过使用”LOCK#”来锁定总线，从而保证操作的原子性
>* （3）因为很多内存数据是已经存放在L1/L2 cache中了，对这些数据的原子操作只需要与本地的cache打交道，而不需要与总线打交道，所以CPU就提供了cache coherency机制来保证其它的那些也cache了这些数据的processor能读到最新的值


所谓原子操作，就是多线程程序中`最小的且不可并行化的`操作。通常对一个共享资源的操作是原子操作的话，意味着多个线程访问资源时，有且仅有唯一一个线程在对这个资源进行操作。那么线程(处理器)的角度看来，其他线程就不能够在本线程对资源访问期间对该资源进行操作，因此原子操作对于多个线程而言，就不会发生有别于单线程程序的意外情况。

```c++
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<long long> total{0}; //只能从模板参数进行构造

void thread_func() {
    for (long long i = 0; i < 100000000LL; ++i) {
        total += 1;
    }
}

int main() {
    std::thread t1(thread_func);
    std::thread t2(thread_func);

    t1.join();
    t2.join();

    std::cout << total << std::endl;
    return 0;
}
```

使得原子类型能够在线程间保持原子性的缘由主要还是因为编译器能够保证针对原子类型的操作都是原子操作。原子操作都是平台相关的，因此有必要为常见的原子操作进行抽象，定义统一的接口，并根据编译器选项(或环境)产生其平台相关的实现

在C++11中，标准将原子操作定义为atomic模板类的成员函数，这囊括了绝大多数典型的操作，如读、写、交换等。当然，对于内置类型而言，主要是通过重载一些全局操作符来完成的。上述代码中的`+=`，使用g++进行编译的话，会产生一条特殊的lock前缀的x86指令，lock能够控制总线及实现x86平台上的原子性加法 

![2017-08-13_15-23-10](http://oowjr8zsi.bkt.clouddn.com/2017-08-13_15-23-10.png)

## 参考资料
[C++ 中的原子性操作](http://lib.csdn.net/article/cplusplus/21872?knId=1169)
