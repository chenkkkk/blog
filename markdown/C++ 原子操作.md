

## 原子操作
所谓原子操作，就是多线程程序中`最小的且不可并行化的`操作。通常对一个共享资源的操作是原子操作的话，意味着多个线程访问资源时，有且仅有唯一一个线程在对这个资源进行操作。那么线程(处理器)的角度看来，其他线程就不能够在本线程对资源访问期间对该资源进行操作，因此原子操作对于多个线程而言，就不会发生有别于单线程程序的意外情况。

> 原子性，也就是要么全部做完，要么全部不做

> 在多进程（线程）访问资源时，能够确保所有其他的进程（线程）都不在同一时间内访问相同的资源。原子操作（atomic operation）是不需要同步，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。

硬件机制所保证的原子性
>* （1）一些基本的内存读写操作是本身已经被硬件提供了原子性保证（例如读写单个字节的操作）；
>* （2）一些需要保证原子性但是没有被第（1）条机制提供支持的操作（例如read-modify-write）可以通过使用”LOCK#”来锁定总线，从而保证操作的原子性
>* （3）因为很多内存数据是已经存放在L1/L2 cache中了，对这些数据的原子操作只需要与本地的cache打交道，而不需要与总线打交道，所以CPU就提供了cache coherency机制来保证其它的那些也cache了这些数据的processor能读到最新的值


## atomic
```c++
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<long long> total{0}; //只能从模板参数进行构造

void thread_func() {
    for (long long i = 0; i < 100000000LL; ++i) {
        total += 1;
    }
}

int main() {
    std::thread t1(thread_func);
    std::thread t2(thread_func);

    t1.join();
    t2.join();

    std::cout << total << std::endl;
    return 0;
}
```

使得原子类型能够在线程间保持原子性的缘由主要还是因为编译器能够保证针对原子类型的操作都是原子操作。原子操作都是平台相关的，因此有必要为常见的原子操作进行抽象，定义统一的接口，并根据编译器选项(或环境)产生其平台相关的实现

![2017-08-13_15-23-10](http://oowjr8zsi.bkt.clouddn.com/2017-08-13_15-23-10.png)

在C++11中，标准将原子操作定义为atomic模板类的成员函数，这囊括了绝大多数典型的操作，如读、写、交换等。当然，对于内置类型而言，主要是通过重载一些全局操作符来完成的。上述代码中的`+=`，使用g++进行编译的话，会产生一条特殊的lock前缀的x86指令，lock能够控制总线及实现x86平台上的原子性加法 

atomic_flag是一个比较特殊的布尔型的atomic类型(atomic_flag和atomic_bool是不同的)：相比于其他的atomic类型，atomic_flag是无锁的，即线程对其访问不需要加锁，因此对atomic_flag而言，也就不需要使用load、store等成员函数进行读写(或者重载操作符)，可以基于此实现自旋锁

```c++
/* 无锁编程 */
void lock(atomic_flag* lock){
    while(lock.test_and_set());//用于在一个内存空间原子地写入新值并且返回旧值
}
void un_lock(atomic_flag* lock) {lock.clear();}
```

## 内存模型：顺序一致性与memory_order
如果只是简单的想在线程间进行数据的同步的话，原子类型已经提供了一些同步的保障。不过这样做的安全性确实建筑与一个假设之上，即所谓的顺序一致性(sequential consistent)的内存模型(memory model)

```c++
#include <thread>
#include <atomic>
#include <iostream>
using namespace std;

atomic<int> a;
atomic<int> b;

int thread1(int) {
    int t = 1;
    a = t;
    b = 2;
}

int thread2(int) {
    while(b != 2) ; //自旋等待
    cout << a << endl; //总是期待a的值为1
}

int main() {
    thread t1(thread1, 0);
    thread t2(thread2, 0);
    
    t1.join();
    t2.join();
    return 0;
}
```

如果编译器认定a、b的赋值语句的执行先后顺序对输出结果没有任何影响的话，则可以依情况将指令重排序(reorder)以提高性能。而如果a、b赋值语句的执行顺序必须是a先b后，则编译器不会执行这样的优化

实际上默认情况下，在C++11中的原子类型的变量在线程中总是保持这顺序执行的特性(非原子类型则没有必要，因为不需要在线程间进行同步)。我们称这样的特性为`顺序一致`的，即代码在线程中运行的顺序与程序员看到的代码顺序一致，a的赋值语句永远发生在b的赋值语句之前

通常情况下，内存模型通常是一个硬件上的概念，表示的是机器指令是以什么样的顺序被处理器执行的。现代的处理器并不是逐条处理机器指令的，可能乱序发射，即在一个时钟周期里发射多条指令。那么强顺序意味着：对于多个线程而言，其看到的指令顺序是一致的。具体地，对于共享内存的处理器而言，需要看到内存中的数据被改变的顺序与机器指令中的一致。在现实中，x86都是被看作采用强顺序内存模型的平台。对于任何一个线程而言，其看到原子操作都是顺序的。而对于采用弱顺序内存模型的平台，比如PowerPC、Armv7这样的平台而言，如果要保证指令执行的顺序，通常需要由在汇编指令中加入一条所谓的内存栅栏(memory barrier)指令，迫使已进入流水线中的指令都完成后处理器才执行sync以后指令(排空流水线)，这样sync之前运行的指令总是先与sunc之后的指令完成的

在高级语言和机器指令间还有一层隔离，这层隔离就是由编译器来完成的，因此是否指令重排序优化，加入内存栅栏都是编译器做的。因此对于弱内存模型的平台，原子操作不仅禁止了编译器的优化，还插入了大量的内存栅栏，为了解除这样的性能约束，C++11设计者给出的解决方式是让程序员为原子操作指定所谓的内存顺序：memory_order，在顺序无关的情况下可以采用一种松散的内存模型来放松对原子操作的执行顺序的要求，如`a.store(1, memory_order_relaxed);`，该指令可以任由编译器重排序或者由处理器乱序执行

![2017-08-13_16-22-18](http://oowjr8zsi.bkt.clouddn.com/2017-08-13_16-22-18.png)

C++11中所有atomic原子操作的默认值为`memory_order_seq_cst`必须是顺序一致的。

## 参考资料
[C++ 中的原子性操作](http://lib.csdn.net/article/cplusplus/21872?knId=1169)
《深入理解C++11-新特性解析与应用》
